<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.290">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2022-12-11">
<meta name="description" content="Gradient Boosted Decision Trees can be effective models for forecasting.">

<title>iammees - Forecasting with Trees</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">iammees</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/iammees" rel="" target=""><i class="bi bi-github" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Forecasting with Trees</h1>
                  <div>
        <div class="description">
          Gradient Boosted Decision Trees can be effective models for forecasting.
        </div>
      </div>
                </div>
  </div>
    
  
  <div class="quarto-title-meta">

      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">December 11, 2022</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<p>Forecasting, the task of predicting the future, has a vast number of crucially important applications in diverse areas such as medicine, financial decision making, climate modeling, and traffic planning. Consequently, time series modelling has always been an area of intensive research leading to the development of a multitude of different forecasting methods. While traditional approaches are typically model-driven (i.e., they make rather strong assumptions, but don’t require many observations to estimate model parameters), the rise of machine learning has facilitated research into data-driven approaches that require more data but are also much more flexible (see this recent <a href="https://arxiv.org/abs/2212.03523">paper</a> for a deeper dive into the characteristics of forecasting methods).</p>
<p>In particular, recent research appears to be largely concentrated on deep learning-based forecasting, which has indeed led to many successful innovations. In recent forecasting competitions, however, it became apparent that <a href="https://arxiv.org/abs/2009.07701">many teams relied heavily on Gradient Boosted Decision Trees (GBDTs)</a> to achieve top ranks – a finding that underscores the practical relevance and usefulness of tree-based models but doesn’t seem to be reflected yet in the attention of researchers. A recent <a href="https://arxiv.org/abs/2012.03854">review article</a>, for example, that aims to provide an extensive overview of the theory and practice of forecasting doesn’t shed much light on the role of tree-based models. Thus, in this blog post we’ll have a look at why and how GBDTs can be effective models for forecasting. In the process, we’ll also have a look at some model agnostic peculiarities of time series that need to be adressed in any forecasting problem.</p>
<div class="cell" data-execution="{&quot;iopub.execute_input&quot;:&quot;2023-04-13T14:11:09.948157Z&quot;,&quot;iopub.status.busy&quot;:&quot;2023-04-13T14:11:09.946620Z&quot;,&quot;iopub.status.idle&quot;:&quot;2023-04-13T14:11:12.684301Z&quot;,&quot;shell.execute_reply&quot;:&quot;2023-04-13T14:11:12.683015Z&quot;,&quot;shell.execute_reply.started&quot;:&quot;2023-04-13T14:11:09.948067Z&quot;}" data-trusted="true" data-execution_count="6">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> matplotlib.patches <span class="im">import</span> Patch</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sktime.forecasting.model_selection <span class="im">import</span> ExpandingWindowSplitter, SlidingWindowSplitter</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="cell" data-execution="{&quot;iopub.execute_input&quot;:&quot;2023-04-13T14:11:12.686612Z&quot;,&quot;iopub.status.busy&quot;:&quot;2023-04-13T14:11:12.686211Z&quot;,&quot;iopub.status.idle&quot;:&quot;2023-04-13T14:11:12.697181Z&quot;,&quot;shell.execute_reply&quot;:&quot;2023-04-13T14:11:12.695378Z&quot;,&quot;shell.execute_reply.started&quot;:&quot;2023-04-13T14:11:12.686559Z&quot;}" data-trusted="true" data-execution_count="7">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_ax(figsize<span class="op">=</span>(<span class="dv">11</span>, <span class="dv">4</span>), grid<span class="op">=</span><span class="va">False</span>, title<span class="op">=</span><span class="va">None</span>, xlabel<span class="op">=</span><span class="va">None</span>, ylabel<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    _, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>figsize)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> grid:</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>        ax.grid(axis<span class="op">=</span><span class="st">"y"</span>, which<span class="op">=</span><span class="st">"major"</span>, color<span class="op">=</span><span class="st">"#e6e5e3"</span>, zorder<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    ax.tick_params(axis<span class="op">=</span><span class="st">"both"</span>, labelsize<span class="op">=</span><span class="dv">9</span>)</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> spine <span class="kw">in</span> [<span class="st">"top"</span>, <span class="st">"right"</span>]:</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>        ax.spines[spine].set_visible(<span class="va">False</span>)</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> spine <span class="kw">in</span> [<span class="st">"bottom"</span>, <span class="st">"left"</span>]:</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>        ax.spines[spine].set_linewidth(<span class="fl">1.1</span>)</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> title <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>        ax.set_title(title, fontsize<span class="op">=</span><span class="dv">12</span>)</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> xlabel <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>        ax.set_xlabel(xlabel, fontsize<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> ylabel <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>        ax.set_ylabel(ylabel, fontsize<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ax</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<section id="why-use-gbdts" class="level2">
<h2 class="anchored" data-anchor-id="why-use-gbdts">Why use GBDTs?</h2>
<p>What motivates the use of GBDTs for forecasting, particularly as an alternative to neural networks? Let’s have a cursory look at some relevant aspects (a more in-depth discussion of this topic can be found in this <a href="https://www.sciencedirect.com/science/article/pii/S0169207021001679">paper</a>):</p>
<ul>
<li>Model implementation: Libraries like XGBoost and LightGBM are highly optimized and generally work right out of the box (i.e., it is not necessary to change their implementation). In the domain of deep learning, on the other hand, a standard architecture for forecasting has yet to emerge. While many types of models (and frameworks) have been proposed, they often require a non-trivial amount of customizations and/or experiments to work well for a given problem.</li>
<li>Hyperparameters: The default parameterization of standard GBDT libraries often provides a surprisingly competitive performance. Even if not, hyperparameter optimization is relatively straightforward with only a handful of (intuitively quite understandable) hyperparameters to tune. Tuning neural networks, meanwhile, is generally more complex, and is still often said to be more of an art than a science (i.e., it can require a lot of computation-intensive experimentation).</li>
<li>Feature engineering: While neural networks typically require only gentle feature engineering (e.g., lag features), heavy feature engineering is considered the key to building highly competitive forecasting models with GBDTs. Fortunately, successful approaches to past problems can often be transferred to new ones (we’ll dive deeper into this soon), and fast training procedures allow to try out many features. What is very important in deep learning, however, is feature scaling. Unlike GBDTs (where feature scaling doesn’t matter), neural networks are typically very sensitive to the scaling of the features which can be particularly challenging when it comes to scaling lag features. A somewhat similar issue is posed by missing values which are handled natively by standard GBDT implementations but usually require imputation in deep learning.</li>
<li>Diagnosability and interpretability: Arguably, diagnosing and interpreting tree-based models is relatively easy. Looking at solutions to similar problems as well as analyzing feature importances (e.g., using SHAP values) and prediction errors after running some experiments usually reveals directions for future improvements. Diagnosing and interpreting neural networks, on the other hand, is more challenging and time-consuming.</li>
<li>Performance: In principle, tree-based models don’t fall behind neural networks with regard to their forecasting performance. Actually, GBDTs combined with excellent feature engineering can consistently outperform neural networks. If the time series comes from a smooth process (e.g., measurements of a physical system), however, the known bias of neural networks towards smooth solutions will likely be very beneficial.</li>
</ul>
<p>What should we make of this? In short, tree-based models come with a higher ease of use. They can benefit from known best practices and can be improved quite intuitively with feature engineering. In a sense, using GBDTs for forecasting primarily requires an intimate understanding of the data while using deep learning primarily requires an intimate understanding of the model architecture and many experiments.</p>
<p>Before we dive deeper into how GBDTs can be used for forecasting, we’ll visit one topic that is absolutely crucial for tackling time series with any model: model validation.</p>
</section>
<section id="time-series-cross-validation" class="level2">
<h2 class="anchored" data-anchor-id="time-series-cross-validation">Time Series Cross-Validation</h2>
<p>In time series, observations that are close to each other in time are typically highly correlated. This phenomenon is known as <a href="https://en.wikipedia.org/wiki/Autocorrelation">autocorrelation</a> and makes intuitive sense: the sales of a given day generally provide some information about the sales of the next day, for example. It follows that we cannot use the standard cross-validation (CV) schemes (k-fold CV and its derivatives like stratified and group k-fold CV) for forecasting because they are based on the assumption that the samples are independent and identically distributed (i.i.d.) and therefore ignore chronological order. Instead we have to replicate the actual forecasting process by only validating on <em>future</em> data using a procedure called time series cross-validation (<strong>tsCV</strong>, also known as rolling forward CV, walk forward CV, and temporal CV). tsCV can be conducted in two different ways: using <em>expanding</em> windows or using <em>sliding</em> windows.</p>
<div class="cell" data-execution="{&quot;iopub.execute_input&quot;:&quot;2023-04-13T14:11:15.054336Z&quot;,&quot;iopub.status.busy&quot;:&quot;2023-04-13T14:11:15.053519Z&quot;,&quot;iopub.status.idle&quot;:&quot;2023-04-13T14:11:15.068619Z&quot;,&quot;shell.execute_reply&quot;:&quot;2023-04-13T14:11:15.067579Z&quot;,&quot;shell.execute_reply.started&quot;:&quot;2023-04-13T14:11:15.054290Z&quot;}" data-trusted="true" data-execution_count="8">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># adapted from https://scikit-learn.org/stable/modules/cross_validation.html#time-series-split</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>rng <span class="op">=</span> np.random.RandomState(<span class="dv">1</span>)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>cmap_cv <span class="op">=</span> plt.cm.gist_earth</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> rng.randn(<span class="dv">100</span>, <span class="dv">10</span>)</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> plot_cv_indices(cv, X, ax, show_n_splits, lw<span class="op">=</span><span class="dv">10</span>):</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Generate the training/testing visualizations for each CV split</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> ii, (tr, tt) <span class="kw">in</span> <span class="bu">enumerate</span>(cv.split(X)):</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Fill in indices with the training/test groups</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>        indices <span class="op">=</span> np.array([np.nan] <span class="op">*</span> <span class="bu">len</span>(X))</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>        indices[tt] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>        indices[tr] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Visualize the results</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>        ax.scatter(</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>            <span class="bu">range</span>(<span class="bu">len</span>(indices)),</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>            [ii <span class="op">+</span> <span class="fl">0.5</span>] <span class="op">*</span> <span class="bu">len</span>(indices),</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>            c<span class="op">=</span>indices,</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>            marker<span class="op">=</span><span class="st">"_"</span>,</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>            lw<span class="op">=</span>lw,</span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>            cmap<span class="op">=</span>cmap_cv,</span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>            vmin<span class="op">=-</span><span class="fl">0.2</span>,</span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>            vmax<span class="op">=</span><span class="fl">1.2</span>,</span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Formatting</span></span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>    yticklabels <span class="op">=</span> <span class="bu">list</span>(<span class="bu">range</span>(show_n_splits))</span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a>    ax.<span class="bu">set</span>(</span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a>        yticks<span class="op">=</span>np.arange(show_n_splits) <span class="op">+</span> <span class="fl">0.5</span>,</span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a>        yticklabels<span class="op">=</span>yticklabels,</span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a>        xlabel<span class="op">=</span><span class="st">"Sample index"</span>,</span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a>        ylabel<span class="op">=</span><span class="st">"CV iteration"</span>,</span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a>        ylim<span class="op">=</span>[show_n_splits <span class="op">+</span> <span class="fl">0.2</span>, <span class="op">-</span><span class="fl">0.2</span>],</span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a>        xlim<span class="op">=</span>[<span class="dv">0</span>, <span class="dv">100</span>],</span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb3-36"><a href="#cb3-36" aria-hidden="true" tabindex="-1"></a>    ax.legend(</span>
<span id="cb3-37"><a href="#cb3-37" aria-hidden="true" tabindex="-1"></a>        [Patch(color<span class="op">=</span>cmap_cv(<span class="fl">0.02</span>)), Patch(color<span class="op">=</span>cmap_cv(<span class="fl">0.8</span>))],</span>
<span id="cb3-38"><a href="#cb3-38" aria-hidden="true" tabindex="-1"></a>        [<span class="st">"Training set"</span>, <span class="st">"Testing set"</span>],</span>
<span id="cb3-39"><a href="#cb3-39" aria-hidden="true" tabindex="-1"></a>        loc<span class="op">=</span><span class="st">"upper right"</span>,</span>
<span id="cb3-40"><a href="#cb3-40" aria-hidden="true" tabindex="-1"></a>        facecolor<span class="op">=</span><span class="st">"white"</span>, </span>
<span id="cb3-41"><a href="#cb3-41" aria-hidden="true" tabindex="-1"></a>        edgecolor<span class="op">=</span><span class="st">"white"</span></span>
<span id="cb3-42"><a href="#cb3-42" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb3-43"><a href="#cb3-43" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ax</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<section id="expanding-window-setup" class="level3">
<h3 class="anchored" data-anchor-id="expanding-window-setup">Expanding window setup</h3>
<p>In the expanding window setup, the size of the training set increases in each successive CV iteration (i.e., the successive training sets are supersets of their predecessors) which is particularly useful when the dataset at hand is rather small. The visualization below is based on the <a href="https://www.sktime.org/en/stable/api_reference/auto_generated/sktime.forecasting.model_selection.ExpandingWindowSplitter.html"><code>ExpandingWindowSplitter</code></a> provided in the <code>sktime</code> library.</p>
<div class="cell" data-execution="{&quot;iopub.execute_input&quot;:&quot;2023-04-13T14:11:16.268065Z&quot;,&quot;iopub.status.busy&quot;:&quot;2023-04-13T14:11:16.267632Z&quot;,&quot;iopub.status.idle&quot;:&quot;2023-04-13T14:11:16.560381Z&quot;,&quot;shell.execute_reply&quot;:&quot;2023-04-13T14:11:16.559111Z&quot;,&quot;shell.execute_reply.started&quot;:&quot;2023-04-13T14:11:16.268026Z&quot;}" data-trusted="true" data-execution_count="9">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> get_ax(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">3</span>), title<span class="op">=</span><span class="st">"tsCV with expanding windows"</span>)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>tscv_ex <span class="op">=</span> ExpandingWindowSplitter(fh<span class="op">=</span>np.arange(<span class="dv">20</span>), initial_window<span class="op">=</span><span class="dv">20</span>, step_length<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>plot_cv_indices(tscv_ex, X, ax, show_n_splits<span class="op">=</span><span class="dv">4</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="index_files/figure-html/cell-5-output-1.png" class="quarto-discovered-preview-image img-fluid"></p>
</div>
</div>
</section>
<section id="sliding-window-setup" class="level3">
<h3 class="anchored" data-anchor-id="sliding-window-setup">Sliding window setup</h3>
<p>In the sliding window setup, the size of the training set is fixed so that the range of training rows moves forward in time with each CV iteration. Put another way, the oldest observations are dropped when new data is added to the training set, essentially keeping the model from attending to the distant past. Given enough data, this is usually the preferred setup in practice (keeping the size of the training set constant gives a more reliable estimate of a model’s performance). <code>sktime</code>’s <a href="https://www.sktime.org/en/stable/api_reference/auto_generated/sktime.forecasting.model_selection.SlidingWindowSplitter.html"><code>SlidingWindowSplitter</code></a> implements this functionality.</p>
<div class="cell" data-execution="{&quot;iopub.execute_input&quot;:&quot;2023-04-13T14:11:18.661549Z&quot;,&quot;iopub.status.busy&quot;:&quot;2023-04-13T14:11:18.660282Z&quot;,&quot;iopub.status.idle&quot;:&quot;2023-04-13T14:11:19.060018Z&quot;,&quot;shell.execute_reply&quot;:&quot;2023-04-13T14:11:19.058696Z&quot;,&quot;shell.execute_reply.started&quot;:&quot;2023-04-13T14:11:18.661481Z&quot;}" data-trusted="true" data-execution_count="10">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> get_ax(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">3</span>), title<span class="op">=</span><span class="st">"tsCV with sliding windows"</span>)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>tscv_sl <span class="op">=</span> SlidingWindowSplitter(fh<span class="op">=</span>np.arange(<span class="dv">20</span>), window_length<span class="op">=</span><span class="dv">20</span>, step_length<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>plot_cv_indices(tscv_sl, X, ax, show_n_splits<span class="op">=</span><span class="dv">4</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="index_files/figure-html/cell-6-output-1.png" class="img-fluid"></p>
</div>
</div>
</section>
<section id="gap-to-production" class="level3">
<h3 class="anchored" data-anchor-id="gap-to-production">Gap to production</h3>
<p>In practice, there is often one further issue to keep in mind: the training data usually isn’t immediately available (the data has to be collected, validated, prepared, etc.) or other reasons cause a delay until the model can be put in production. If this is the case, the gap should be incorporated into the CV procedure.</p>
<div class="cell" data-execution="{&quot;iopub.execute_input&quot;:&quot;2023-04-13T14:11:20.876789Z&quot;,&quot;iopub.status.busy&quot;:&quot;2023-04-13T14:11:20.876314Z&quot;,&quot;iopub.status.idle&quot;:&quot;2023-04-13T14:11:21.141180Z&quot;,&quot;shell.execute_reply&quot;:&quot;2023-04-13T14:11:21.139738Z&quot;,&quot;shell.execute_reply.started&quot;:&quot;2023-04-13T14:11:20.876745Z&quot;}" data-trusted="true" data-execution_count="11">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> get_ax(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">3</span>), title<span class="op">=</span><span class="st">"tsCV with sliding windows and gaps"</span>)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>tscv_slg <span class="op">=</span> SlidingWindowSplitter(fh<span class="op">=</span>np.arange(<span class="dv">3</span>, <span class="dv">20</span>), window_length<span class="op">=</span><span class="dv">20</span>, step_length<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>plot_cv_indices(tscv_slg, X, ax, show_n_splits<span class="op">=</span><span class="dv">4</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="index_files/figure-html/cell-7-output-1.png" class="img-fluid"></p>
</div>
</div>
</section>
<section id="custom-setup" class="level3">
<h3 class="anchored" data-anchor-id="custom-setup">Custom setup</h3>
<p>The generic approaches outlined above may serve as a basis for developing custom tsCV procedures that consider specific quirks of the dataset (e.g., groups) or better match the characteristics of the project. If the task is to predict daily values for the next four weeks, for example, it may make sense to use only the last four weeks of the training data for validation (or some four week windows near the end of the training data).</p>
<p>Note that it is also possible to combine the expanding and sliding window approach (start with the expanding window setup and switch to the sliding window setup when the window has grown large enough) or compute a weighted average over all test windows to obtain the final CV score (e.g., giving more weight to a validation window that includes the last seasonal period or to the most recent window). Note that the faster training speed of GBDTs can be particularly advantageous in this context since it allows to validate against more validation windows in a timely manner.</p>
</section>
</section>
<section id="evaluation-metric" class="level2">
<h2 class="anchored" data-anchor-id="evaluation-metric">Evaluation Metric</h2>
<p>With the validation scheme set up, choosing the right evaluation metric is the next important choice to make. A huge (and somewhat overwhelming) variety of metrics for evaluating forecasting models has been proposed, each with its own advantages and disadvantages. This 2022 <a href="https://arxiv.org/pdf/2203.10716.pdf">paper</a> provides a thorough review and a nice flowchart for picking the right one(s). In general (and unsurprisingly), the choice of evaluation metrics should be guided by the underlying business problem. In sales forecasting, for example, overestimation might be acceptable to some degree, while underestimation should be avoided (products that are not in stock cannot be sold and being out of stock comes with significant reputational risk); the metric should reflect this. In this context, it may be worthwhile to customize the loss function used by the model (XGBoost, for example, provides a <a href="https://xgboost.readthedocs.io/en/stable/tutorials/custom_metric_obj.html">tutorial</a> on this) and/or transform the target to make the modeling easier.</p>
</section>
<section id="modeling" class="level2">
<h2 class="anchored" data-anchor-id="modeling">Modeling</h2>
<p>In order to apply GBDTs (or other ML methods) to time series, we have to transform the data into a supervised regression problem. This essentially means nothing more than that each row must contain all the features necessary for the model to make a prediction. There are some more aspects to consider, though.</p>
<section id="local-vs.-global-models" class="level3">
<h3 class="anchored" data-anchor-id="local-vs.-global-models">Local vs.&nbsp;global models</h3>
<p>If the dataset contains multiple time series (e.g., sales data for multiple stores), we have to decide whether to develop local models or a global model. While a local model is trained only on a single time series (e.g., on one store), a global model is trained across time series (e.g., on all stores; this is sometimes called cross-learning). If the underlying data generating process is not too dissimilar (or if we have good features that capture the differences), we will usually prefer global models since we can leverage the additional observations to build more complex and robust models. <a href="https://arxiv.org/pdf/2008.00444">Recent research</a> has even shown that global models can work well for heterogenous datasets.</p>
</section>
<section id="multi-step-forecasting" class="level3">
<h3 class="anchored" data-anchor-id="multi-step-forecasting">Multi-step forecasting</h3>
<p>GBDTs generally cannot predict sequences, but many forecasting tasks are sequence-to-sequence problems. That is, we often want to predict multiple time steps into the future. If features computed from recent target values are not crucial for the model, this is not an obstacle; in this case we can treat the problem as a regular regression problem (using one model to predict each row simultaneously). If not, there are essentially two ways to implement this: - Recursive forecasting: Recursively apply a one-step forecasting model, using the predictions of the last step for the computation of lag and window features for the current step. With this strategy the model has to be trained only once, but the accumulation of prediction errors can result in very bad model performance. - Direct forecasting: Directly predict the entire future sequence using multiple models (i.e., train one model for each forecasting step). Requires more computation, but avoids the accumulating bias of the recursive approach.</p>
<p>The ideal strategy depends on many factors like the forecast horizon, the size of the dataset, the complexity of the model and the problem, as well as time and resource constraints.</p>
</section>
<section id="naive-baseline" class="level3">
<h3 class="anchored" data-anchor-id="naive-baseline">Naive baseline</h3>
<p>When tackling forecasting problems, it is absolutely essential to compare models against naive baselines. The most common techniques: - For non-seasonal time series, predict the last observed value. This is the simplest possible benchmark and sometimes called the persistence model or no-change model. In general, the more a time series resembles a random walk, the competitive the naive benchmark will be. - For seasonal time series, predict the last observed seasonal value (e.g., predict the value exactly one week ago in a series with weekly periodicity). This is known as the seasonal naive method.</p>
<p>Of course, there may be other naive approaches that are appropriate for a particular dataset or problem (e.g., predict the median of last week), and it is generally worthwhile to check the performance of traditional (statistical) forecasting methods like ARIMA or Exponential Smoothing. Surprisingly often one finds that these baselines are quite hard to beat. Even if not, more complex models sometimes provide only a relatively small percentage improvement. (These little improvements, however, might very well have huge consequences in practice.)</p>
</section>
<section id="trend-adjustment" class="level3">
<h3 class="anchored" data-anchor-id="trend-adjustment">Trend adjustment</h3>
<p>GBDTs cannot extrapolate trends. To deal with this, we can modify the target by detrending the time series. There are multiple options to do this: - create a new target (e.g., subtract the mean target value of the last month or the last seasonal value) - predict the residuals of a baseline model (e.g., a ridge regression model or even a more complex sequence-to-sequence neural network) - use the predictions of a baseline model as a feature (e.g., a linear model with time steps as features or a more complex model)</p>
</section>
<section id="post-processing" class="level3">
<h3 class="anchored" data-anchor-id="post-processing">Post processing</h3>
<p>Sometimes a simple post-processing measure (e.g., multiplying predictions by a constant just above or below <span class="math inline">\(1\)</span>) can be used to correct systematic biases of a forecasting model. Of course, it is generally a bad sign when a simple technique like that leads to significant improvements; there should be a principled way to correct a systematic error by improving the model itself. In practice though, this may be easier said than done.</p>
</section>
</section>
<section id="feature-engineering" class="level2">
<h2 class="anchored" data-anchor-id="feature-engineering">Feature Engineering</h2>
<p>Finally, let’s turn our attention to feature engineering. As with tabular data, feature engineering is crucial when tackling time series problems with tree-based methods. But due to the time dimension of the data, there are some kinds of features that are not seen in tabular problems.</p>
<section id="temporal-features" class="level3">
<h3 class="anchored" data-anchor-id="temporal-features">Temporal features</h3>
<p>Many useful features can be derived from the date or time stamp associated with each observation. Some examples:</p>
<ul>
<li>time steps</li>
<li>hour of day</li>
<li>day of week</li>
<li>week of year</li>
<li>month</li>
<li>quarter</li>
<li>season</li>
<li>is weekend</li>
<li>is public holiday (is christmas, is easter, etc.)</li>
<li>is school holiday</li>
<li>is payday week</li>
<li>is daylight saving time</li>
<li>is event (e.g., is promotion, is world cup game, is first Saturday of the month, etc.)</li>
<li>event counters (e.g., the number of days until, into, and after an event)</li>
<li>number of trading days in month</li>
<li>weights (e.g., put a higher weight on more recent observations or the last seasonal period)</li>
<li>Fourier features</li>
</ul>
</section>
<section id="lag-features" class="level3">
<h3 class="anchored" data-anchor-id="lag-features">Lag features</h3>
<p>Lag features represent values at prior timesteps (e.g., the number of restaurant reservations on the same day last week, number of radio ads run yesterday). They can be computed for both the target and features and usually turn out to be important predictors in practice (in sales forecasting, for example, the last available value will hold a lot of information).</p>
</section>
<section id="window-features" class="level3">
<h3 class="anchored" data-anchor-id="window-features">Window features</h3>
<p>Window (or rolling) features compute a summary statistic over a window of past data. This too can be done for both the target (e.g., the mean, median, standard deviation etc. of last week) and features (e.g., the minimum weekly ad spend last month). In general, one can try computing statistics for different periods (e.g., last day, the same period last season), different groups (e.g., days of the week, events), and different levels of the hierarchy (e.g., department level, state level, country level).</p>
<p>The optimal window sizes generally depend on the patterns in the data, but because using window features renders the data at the beginning of the time series unusable (the window features would be NaNs) it is usually better to avoid large window sizes.</p>
</section>
<section id="difference-features" class="level3">
<h3 class="anchored" data-anchor-id="difference-features">Difference features</h3>
<p>Computing differences between different points in time (or aggregations) is another strategy that is often very useful. Intuitively, difference features help the model understand changes over time or fluctuations (e.g., subtract the weekly mean from daily observations to see how each day differs from the mean).</p>
</section>
<section id="finding-good-features" class="level3">
<h3 class="anchored" data-anchor-id="finding-good-features">Finding good features</h3>
<p>How can we find good features? There are some strategies that can help:</p>
<ul>
<li>Analyze the seasonalities</li>
<li>Plot the prediction errors of the model (over the entire series, by seasonality, by length of the forecast horizon, by groups in the data, etc.)</li>
<li>Analyze feature importances over different periods</li>
<li>Analyze solutions to similar problems</li>
</ul>
</section>
<section id="avoid-temporal-leaks" class="level3">
<h3 class="anchored" data-anchor-id="avoid-temporal-leaks">Avoid temporal leaks</h3>
<p>A final word of caution: when creating time-related features it is imperative to make sure that all values will be available at inference time. A rather obvious example is weather data: knowing the amount of rain or the average windspeed on a given day will most likely be of value when predicting drug store sales, but these data won’t be readily available in advance. Whether or not it is possible to use predictions for these kinds of features depends on the problem (e.g., it will probably work to use weather forecasts when we only want to predict the next three days, but get prohibitively hard when we want to predict the sales of a whole month). A trickier example is target encoding (or any computation over the entire series): using the entire training data (i.e.&nbsp;before creating the CV split) for target encoding will create a temporal leak, causing us to overestimate the performance of the model. At inference time data leaks will end up being (highly) detrimental and might even cause the model to fail entirely.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  let localAlternateSentinel = 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>